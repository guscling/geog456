<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css"
    integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ=="
    crossorigin=""/>    
    <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"
    integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ=="
    crossorigin=""></script>
    
    <script src='./EU_migration_Data_simplified.js'></script>
    <script src='./marker_points.js'></script>

    <link rel="stylesheet" href="./Control.MiniMap.min.css">
    <script src="./Control.MiniMap.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!--<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>-->

<!-- <script type="module">import center from './@turf/center';</script>
    <script type="module">import centroid from './@turf/centroid';</script> -->

    </script>

    <style>
        /*Help from Chat Gpt with CSS code*/
        body {
            background-color: #f0f0f0;
        }

        #wrapper { /* Contains everything but the title */ 
            display: flex;
            height: 100vh;
            width: 100%;
            min-height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #map { /* Div for the map*/
            flex: 1;
            height: 100%;
            min-height: 100%;
            width: 100%;
            float: right; 
            background-color: black; 
            border: 1px solid black;
            z-index: 50;
        }

        #sideBar { /*the div next to the map containing buttons, explanation, and chart placeholder*/
            width: 30%;
            min-width: 408px;
            padding: 20px;
            box-sizing: border-box;
            background-color: #f0f0f0;
            float: left;
            max-width: 500px;
        }

        .button {
            margin-bottom: 10px;
            padding:   4% 4%;
            font-size: 16px;
            background-color: rgb(73, 62, 62);
            color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
        }
        .button:hover {
            background-color: #9f9090; 
        }

       .legend { /*Legend on the map*/
            line-height: 18px;
            font-weight: bold;
        }
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }
        .info.legendMarker {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            font-weight: bold;
            
        }
        .info.legendMarker span {
            margin-right: 10px;
            margin-bottom: -2px;
            font-weight: bold;
        }

        #title{
            float: top;
            text-align: center;
            font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            position:relative; 
        }

        #migrationChartContainer{ 
            height: 40%;
            width: 100%;
            max-width: 450px;
            border: solid black;
            margin-top: 20px;
            display: flex;
            align-items: center;
            background-color: #ffffff;
        }

        #migrationChart {
            width: 100%;
            height: 150%;
            justify-content: center;

        }
        #dataExplanation{
            text-align: left;
            font-size:.144in;
        }
    </style>
</head>

<body>
    <h1 id="title">Is Public Opinion of Migration Impacted by the Number of Assylum Seekers in the EU?</h1>
    <div id="wrapper">
        <div id="sideBar">
            <div id="buttonContainer"> 
                <button class="button" id="Button2014">2014</button>
                <button class="button" id="Button2015">2015</button>
                <button class="button" id="Button2016">2016</button>
                <button class="button" id="Button2017">2017</button>
                <button class="button" id="Button2018">2018</button>
                <button class="button" id="Button2019">2019</button>
                <button class="button" id="Button2020">2020</button>
                <button class="button" id="Button2021">2021</button>
                <button class="button" id="Button2022">2022</button>
                <button class="button" id="Button2023">2023</button>
            </div>
            <div id="explanation wrapper">
            <div id="dataExplanation"></div>
            <p><a href="https://guscling.github.io/geog456/Final%20Project/data_explanation" target=”_blank”>Complete explanation of data sources and usage</a>
            </div>
            <p id="totalApps"></p>
            <div id="migrationChartContainer">
                <canvas id="migrationChart"></canvas>
            </div>
        </div>
        <div id="map"></div>
    </div>

    <script>
        //Automatically spertes thousands with commas when applied-- from stackexchange
        function numberWithCommas(x) {
            return x.toString().replace(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, ",");
}
    
        // Add leflet map and json layer to it
        var map = L.map('map',{
            zoomControl: false,
            scrollWheelZoom: false,
            minZoom: 4,
            maxZoom:6,
            attributionControl: false,
        }).setView([55.55349545845371,23.942223059183976], 4)
            L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_toner_lite/{z}/{x}/{y}{r}.png?api_key=c72e380a-078b-4579-84ab-95ae1f64f20d', {
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                fitBounds:map.getBounds(),
                }).addTo(map);
        //prevent map from zooming or moving 
        map.doubleClickZoom.disable();
        map.dragging.disable();

        // Set year variable used for updating data- Initially set at 2014 with querySelector of first button
        var yearText = document.querySelector('.button').textContent;
        var year = parseInt(yearText)

        // Select the color of the tiles based on positive and negative opinion responses
        function getColorPos(p) {
        return p > 80  ? '#276419' :
               p > 60  ? '#4d9221' :
               p > 40  ? '#7fbc41' :
               p > 20  ? '#b8e186' :
               p > 0   ? '#e6f5d0' :
                         'transparent';
        }

        function getColorNeg(n) {
        return  n > 80  ? '#8e0152' :
                n > 60  ? '#c51b7d' :
                n > 40  ? '#de77ae' :
                n > 20  ? '#f1b6da' :
                n >  0  ? '#fde0ef' :
                          'transparent';
        }

        // Select the radius of the circle markers based on the number of applicants
        function getSize(a) {
            return a > 500000 ? 38:
                   a > 100000 ? 30:
                   a > 50000  ? 25:
                   a > 10000  ? 20:
                   a > 5000   ? 15:
                   a > 500    ? 10:
                   a < 100    ? 5:
                   
                                0;            
        }
        //Make values with no data invisible (UK after 2019)
        function circleColor(a) {
            return a > 0 ? "black":
                        "transparent"
        }
        //Sets the radius of the circle markers
        function radius(feature) {
            
            var assylumApps = feature.properties["GEOG456_Total_Data_Assylum_Apps_" + year];
            var radius = getSize(assylumApps)
            var color = circleColor(assylumApps)
    

            return {
                radius: radius,
                fillColor: "transparent",
                color: color,
                dashArray:4,
                weight: 2.5,
                opacity: 1,
                fillOpacity: 0.8}
            }
        
    
        //Set color of country polygons
        function style(feature) {

            var positiveOpinon = feature.properties["GEOG456_Total_Data_" + year + "_Positive"];
            var negativeOpinon = feature.properties["GEOG456_Total_Data_" + year + "_Negative"];
            var fillColor = positiveOpinon > negativeOpinon ? getColorPos(positiveOpinon) : getColorNeg(negativeOpinon);

            return {
                fillColor: fillColor,
                weight: 2,
                opacity: 1,
                color: 'white',
                dashArray: '3',
                fillOpacity: 0.7
                };
            }

        // Add geoJSON data to map as polygon and circle markers, setting style as above
        var addPolyJson = L.geoJSON(migrationData, {style: style}).addTo(map);
        var addPointJson = L.geoJSON(points, {
            pointToLayer: function (feature, latlng) {
                return L.circleMarker(latlng, radius);
        }
            }).setStyle(radius).addTo(map);

        //Button function
        //Sets the style of polygons and markers based on data from slected year
        // Also changes data for minimaps and popup markers
        const myButtons = document.querySelectorAll("button");
        let selectedButton = null;
        myButtons.forEach(button => {
            button.addEventListener('click', () => {
                if (selectedButton) {
                    selectedButton.style.backgroundColor = '';
                }
                map.removeLayer(addPolyJson);
                map.removeLayer(addPointJson);
                yearText = button.textContent;
                year = parseInt(yearText);
                addPolyJson = L.geoJSON(migrationData, {style: style}).addTo(map);
                addPointJson.setStyle(radius)
                addPointJson.addTo(map);
                miniPolyStyleBen(year);
                miniMarkerStyleBen(year);
                miniPolyStyleCen(year);
                miniMarkerStyleCen(year);  
                miniPolyStyleMal(year);
                miniMarkerStyleMal(year);
                dataExplanation(year);
                document.getElementById('Button'+year).style.backgroundColor = '#9f9090'
                selectedButton = button;
                document.getElementById('totalApps').innerHTML = "TOTAL ASSYLUM APPLICANTS IN " + year + ": " + "<b>" + numberWithCommas(migrationData.features[28].properties["GEOG456_Total_Data_Assylum_Apps_"+year])+"</b>";
            })
        });

        //Create legend for positive colors
        var legendPos = L.control({position: 'topleft'});
        legendPos.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info legend');
            var title = '<strong>Percent Positive Responses</strong><br>';
            var grades = [0, 20, 40, 60, 80];
            var labels = [];

            for (var i = 0; i < grades.length; i++) {
                labels.push(
                    '<i style="background:' + getColorPos(grades[i] + 1) + '"></i> ' +
                    grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] : '+')
                );
            }

            div.innerHTML = title + labels.join('<br>');
            return div;
        };
        legendPos.addTo(map);

        //Create legend for negative colors
        var legendNeg = L.control({position: 'topleft'});
        legendNeg.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info legend');
            var title = '<strong>Percent Negative Responses</strong><br>'; 

            var grades = [0, 20, 40, 60, 80];
            var labels = [];

            for (var i = 0; i < grades.length; i++) {
                labels.push(
                    '<i style="background:' + getColorNeg(grades[i] + 1) + '"></i> ' +
                    grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1]: '+')
                );
            }

            div.innerHTML = title + labels.join('<br>');
            return div;
        };
        legendNeg.addTo(map);

        //Create legend for marker radius
        var legendMarker = L.control({ position: 'topleft' });
        legendMarker.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info legendMarker');
            var title = '<strong>Number of Assylum <br> Applicants</strong><br>'; 
            var grades = [0,500,5000,10000,50000,100000,500000];
            var labels = [];

            for (var i = 0; i < grades.length; i++) {
                var size = getSize(grades[i] + 1)*2;
                labels.push(
                    '<i style="background: transparent;"></i> ' +
                    '<span style="display: inline-block; width: ' + size + 'px; height: ' + size + 'px; background-color: transparent; border-radius: 50%; border: 3px dashed black;"></span> ' +
                    grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] : '+')
                );
            }

        div.innerHTML = title + labels.join('<br>');
        return div;
        };
        legendMarker.addTo(map);

        //Create minimap centered on Benelux
        var miniOsmBen = L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_toner_lite/{z}/{x}/{y}{r}.png?api_key=c72e380a-078b-4579-84ab-95ae1f64f20d', {
                    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                    minZoom: 6,
                    maxZoom: 6,
        });
        //import geoJSON
        var miniPolyBen = L.geoJSON(migrationData, {style: style});
        var miniMarkersBen = L.geoJSON(points, {
            pointToLayer: function (feature, latlng) {
            return L.circleMarker(latlng, radius);
        }
            }).setStyle(radius);
        //Group vectors and map in layer group
        var miniLayersBen = new L.LayerGroup([miniPolyBen,miniMarkersBen,miniOsmBen]);
        //Create map on bottom right
        var miniMapBen = new L.Control.MiniMap(miniLayersBen, {
            centerFixed: [51.4, 5.4623],
            zoomLevelFixed: 6,
            height: 300,
            width: 300,
            aimingRectOptions: {color: 'transparent'},
            position:'bottomright',
            }).addTo(map);
        //Set style of polygons
        function miniPolyStyleBen(year) {
            miniPolyBen.setStyle(function (feature) {
                var positiveOpinon = feature.properties["GEOG456_Total_Data_" + year + "_Positive"];
                var negativeOpinon = feature.properties["GEOG456_Total_Data_" + year + "_Negative"];
                var fillColor = positiveOpinon > negativeOpinon ? getColorPos(positiveOpinon) : getColorNeg(negativeOpinon);
                return{
                    fillColor:fillColor,
                    weight: 2,
                    opacity: 1,
                    color: 'white',
                    dashArray: '3',
                    fillOpacity: 0.7,
                };
            });
        };
        //Set style of points
        function miniMarkerStyleBen(year) {
            miniMarkersBen.eachLayer(function (layer) {
                var assylumApps = layer.feature.properties["GEOG456_Total_Data_Assylum_Apps_" + year];
                var radius = getSize(assylumApps);
                var color = circleColor(assylumApps);
                layer.setStyle({
                    radius: radius,
                    fillColor: "transparent",
                    color: color,
                    dashArray: 4,
                    weight: 2.5,
                    opacity: 1,
                    fillOpacity: 0.8,
                });
            });
        }

        //Create minimap centered on Benelux
        var miniOsmCen = L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_toner_lite/{z}/{x}/{y}{r}.png?api_key=c72e380a-078b-4579-84ab-95ae1f64f20d', {
                    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                    minZoom: 5,
                    maxZoom: 5,
        });
        //Import geoJSON
        var miniPolyCen = L.geoJSON(migrationData, {style: style});  
        var miniMarkersCen = L.geoJSON(points, {
            pointToLayer: function (feature, latlng) {
                return L.circleMarker(latlng, radius);
        }
            }).setStyle(radius);
        //Geoup map and vectors in layer group    
        var miniLayersCen = new L.LayerGroup([miniOsmCen,miniMarkersCen,miniPolyCen]);
        //Create map on top right
        var miniMapCen = new L.Control.MiniMap(miniLayersCen, {
            centerFixed: [47.6817, 16.5845],
            zoomLevelFixed: 5,
            height: 250,
            width: 250,
            position: 'topright',
            aimingRectOptions: {color: 'transparent'},
            }).addTo(map);
        //Set style of polygons
        function miniPolyStyleCen(year) {
            miniPolyCen.setStyle(function (feature) {
                var positiveOpinon = feature.properties["GEOG456_Total_Data_" + year + "_Positive"];
                var negativeOpinon = feature.properties["GEOG456_Total_Data_" + year + "_Negative"];
                var fillColor = positiveOpinon > negativeOpinon ? getColorPos(positiveOpinon) : getColorNeg(negativeOpinon);
                return{
                    fillColor:fillColor,
                    weight: 2,
                    opacity: 1,
                    color: 'white',
                    dashArray: '3',
                    fillOpacity: 0.7
                };
            });
        };
        //Set style of markers
        function miniMarkerStyleCen(year) {
            miniMarkersCen.eachLayer(function (layer) {
                var assylumApps = layer.feature.properties["GEOG456_Total_Data_Assylum_Apps_" + year];
                var radius = getSize(assylumApps);
                var color = circleColor(assylumApps);
                layer.setStyle({
                    radius: radius,
                    fillColor: "transparent",
                    color: color,
                    dashArray: 4,
                    weight: 2.5,
                    opacity: 1,
                    fillOpacity: 0.8
                });
            });
        }
        //Create minimap centered on Malta
        var miniOsmMal = L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_toner_lite/{z}/{x}/{y}{r}.png?api_key=c72e380a-078b-4579-84ab-95ae1f64f20d', {
                    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                    minZoom:8,
                    maxZoom:8,
        });
        //Add geoJSON data and group with map
        var miniPolyMal = L.geoJSON(migrationData, {style: style});    
        var miniMarkersMal = L.geoJSON(points, {
            pointToLayer: function (feature, latlng) {
                return L.circleMarker(latlng, radius);
        }
            }).setStyle(radius);
        var miniLayersMal = new L.LayerGroup([miniOsmMal,miniMarkersMal,miniPolyMal]);
        //Add minimap top right
        var miniMapMal = new L.Control.MiniMap(miniLayersMal, {
            centerFixed: [35.8992, 14.4141],
            zoomLevelFixed: 8,
            height: 150,
            width: 150,
            position: 'topright',
            aimingRectOptions: {color: 'transparent'},
            }).addTo(map);
        //Set style of polygons 
        function miniPolyStyleMal(year) {
            miniPolyMal.setStyle(function (feature) {
                var positiveOpinon = feature.properties["GEOG456_Total_Data_" + year + "_Positive"];
                var negativeOpinon = feature.properties["GEOG456_Total_Data_" + year + "_Negative"];
                var fillColor = positiveOpinon > negativeOpinon ? getColorPos(positiveOpinon) : getColorNeg(negativeOpinon);
                return{
                    fillColor:fillColor,
                    weight: 2,
                    opacity: 1,
                    color: 'white',
                    dashArray: '3',
                    fillOpacity: 0.7
                };
            });
        };
        //Set style for markers
        function miniMarkerStyleMal(year) {
            miniMarkersMal.eachLayer(function (layer) {
                var assylumApps = layer.feature.properties["GEOG456_Total_Data_Assylum_Apps_" + year];
                var radius = getSize(assylumApps);
                var color = circleColor(assylumApps);
                layer.setStyle({
                    radius: radius,
                    fillColor: "transparent",
                    color: color,
                    dashArray: 4,
                    weight: 2.5,
                    opacity: 1,
                    fillOpacity: 0.8
                });
            });
        }
        // Create name lable markers for minimaps
        var labelMal = new L.marker([35.4962, 14.961], { opacity: 0.01 });
        labelMal.bindTooltip("Malta", { permanent: true, offset: [0, 0] });
        labelMal.addTo(miniLayersMal);

        var labelCen = new L.marker([43.4563, 23.0131], { opacity: 0.01 });
        labelCen.bindTooltip("Central Europe", { permanent: true, offset: [0, 0] });
        labelCen.addTo(miniLayersCen);

        var labelBen = new L.marker([49.1253, 9.2396], { opacity: 0.01 });
        labelBen.bindTooltip("Benelux", { permanent: true, offset: [0, 0] });
        labelBen.addTo(miniLayersBen);

        //Set data explanation about survey question for the relevant year in the sidebar 
        function dataExplanation(year) {
            var docExp = document.getElementById("dataExplanation");
            if (year == 2021){
                docExp.innerHTML=("<p>The data is based on the <i>Problem</i> and <i>Opportunity</i> responses to the Eurobarometer survey question: <b><u>Generally speaking, do you think immigration from outside the EU is more of a problem or more of an opportunity for ([YOUR] COUNTRY) today?</u></b> For the purpose of mantaining a diverging symbology, the responses <i>Is equally a problem and an opportunity</i> and <i>Is neither a problem nor an opportunity</i> are ignored, which account for a large portion of the responses to this question</p> <b>NOTE THAT THIS DATA COMES FROM A DIFFERENT QUESTION AND IS NOT DIRECTLY COMPARABLE TO THE OTHER YEARS</b>" );
            } else if (year == 2022){
                docExp.innerHTML=("<p>The data is based on the total <i>Worred</i> and <i>Not Worried</i> responses to the Eurobarometer survey question: <b><u>'To what extent are you currently worried or not about each of the following issues for your life and those of your close ones: Migration'</u></b>. <i>Worried</i> is considered the negative response while <i>Not Worried</i> is considered the positive response</p> <b>NOTE THAT THIS DATA COMES FROM A DIFFERENT QUESTION AND IS NOT DIRECTLY COMPARABLE TO THE OTHER YEARS</b>");
            } else {
                docExp.innerHTML=("<p>The data is based on the total <i>Negative</i> and <i>Positive</i> responses to the Eurobarometer survey question: <b><u>'Please tell me whether each of the following statements evokes a positive or negative feeling for you. Immigration of people from outside the EU'</u></b></p>");
            };
        };



        //Help from ChatGPT
        function getCountryData(countryName, years) {
            let countryData = [];

            let countryFeature = migrationData.features.find(feature => feature.properties.GEOUNIT === countryName);

            if (countryFeature) {
                years.forEach(year => {
                    if (countryFeature.properties[`GEOG456_Total_Data_Assylum_Apps_${year}`]) {
                        countryData.push(countryFeature.properties[`GEOG456_Total_Data_Assylum_Apps_${year}`]);
                    }
                });
            }

        return countryData;
        }

        //ChatGPT
        //Gets the aaplicationd ata for a country when clicked and creates a chart based on it
        let migrationChart;

        function createChart(event) {
            
            let layer = event.layer;
            
            migrationData.features.forEach(feature => {
                let layer = L.geoJSON(feature);
                if (layer && layer.getBounds().contains(event.latlng)) {
                    let countryName = feature.properties.GEOUNIT;
                    let countryData = getCountryData(countryName, [2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023]);
                    updateChart(countryName, countryData);
                }
            });
        }

        function updateChart(countryName, data) {
            if (migrationChart) {
                migrationChart.destroy(); 
            }
            let barData = {
                labels: ['2014', '2015', '2016', '2017', '2018', '2019', '2020', '2021', '2022', '2023'],
                datasets: [{
                    label: countryName + " APPLICATIONS BY YEAR",
                    backgroundColor: 'rgba(54, 162, 235, 0.5)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1,
                    data: data,
                }]
            };

        let barOptions = {
            scales: {
                y: {
                    beginAtZero: true
                },
            responsive: true,
            maintainAspectRatio: false,
        }

        };

        const ctx = document.getElementById('migrationChart').getContext('2d');
        migrationChart = new Chart(ctx, {
            type: 'bar',
            data: barData,
            options: barOptions
        });
        }

        map.on('click', createChart);
        

        //On load of page, select 2014 button (and set the)
        document.getElementById('Button2014').click();

    </script>
    
</body>
</html>